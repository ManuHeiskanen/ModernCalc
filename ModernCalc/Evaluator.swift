import Foundation

enum MathError: Error, CustomStringConvertible {
    case divisionByZero
    case unknownOperator(op: String)
    case unknownConstant(name: String)
    case unknownFunction(name: String)
    case invalidNode
    case typeMismatch(expected: String, found: String)
    case unsupportedOperation(op: String, typeA: String, typeB: String?)
    case dimensionMismatch(reason: String)
    case incorrectArgumentCount(function: String, expected: String, found: Int)
    case requiresAtLeastOneArgument(function: String)
    case plotError(reason: String)
    case unitConversionError(from: String, to: String)
    case solverFailed(reason: String)

    var description: String {
        switch self {
        case .divisionByZero: return "Error: Division by zero."
        case .unknownOperator(let op): return "Error: Unknown operator '\(op)'."
        case .unknownConstant(let name): return "Error: Unknown constant or unit '\(name)'."
        case .unknownFunction(let name): return "Error: Unknown function '\(name)'."
        case .invalidNode: return "Error: The expression tree contains an invalid node."
        case .typeMismatch(let expected, let found): return "Error: Type mismatch. Expected \(expected), but found \(found)."
        case .unsupportedOperation(let op, let typeA, let typeB):
            if let typeB = typeB {
                if typeA == "Tuple" && typeB == "Tuple" {
                    return "Error: Operations between two multi-valued results are not supported."
                }
                return "Error: Operator '\(op)' is not supported between \(typeA) and \(typeB)."
            }
            if typeA == "hyp < side" { return "Error: Hypotenuse must be greater than or equal to the side." }
            if typeA == "Singular Matrix" { return "Error: Matrix is singular and cannot be inverted."}
            return "Error: Operator '\(op)' is not supported for \(typeA)."
        case .dimensionMismatch(let reason): return "Error: Dimension mismatch. \(reason)."
        case .incorrectArgumentCount(let function, let expected, let found): return "Error: Function '\(function)' expects \(expected) argument(s), but received \(found)."
        case .requiresAtLeastOneArgument(let function): return "Error: Function '\(function)' requires at least one argument."
        case .plotError(let reason): return "Plot Error: \(reason)."
        case .unitConversionError(let from, let to): return "Error: Cannot convert from \(from) to \(to). Units must have the same physical dimension."
        case .solverFailed(let reason): return "Solver Error: \(reason)."
        }
    }
}

/// The core evaluation engine. This struct contains the main recursive evaluation loop (`_evaluateSingle`)
/// that traverses the abstract syntax tree (AST) generated by the Parser.
struct Evaluator {

    let h = 1e-5 // A small step size for numerical differentiation

    /// A helper function to evaluate an expression with a temporary variable, used for calculus operations.
    func evaluateWithTempVar(node: ExpressionNode, varName: String, varValue: MathValue, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (result: MathValue, usedAngle: Bool) {
        var tempVars = variables
        tempVars[varName] = varValue
        let (result, usedAngle) = try _evaluateSingle(node: node, variables: &tempVars, functions: &functions, angleMode: angleMode)
        return (result, usedAngle)
    }
    
    /// The main entry point for evaluating an expression node. It handles expanding multi-value results (from `±`).
    func evaluate(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (result: MathValue, usedAngle: Bool) {
        let (results, usedAngle) = try evaluateAndExpand(node: node, variables: &variables, functions: &functions, angleMode: angleMode)
        if results.count == 1 {
            return (results[0], usedAngle)
        } else {
            return (.tuple(results), usedAngle)
        }
    }
    
    /// Recursively evaluates an expression, handling the `±` operator by creating multiple evaluation paths.
    private func evaluateAndExpand(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (results: [MathValue], usedAngle: Bool) {
        if let binaryNode = node as? BinaryOpNode, binaryNode.op.rawValue == "±" {
            let (leftResults, leftUsedAngle) = try evaluateAndExpand(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
            let (rightResults, rightUsedAngle) = try evaluateAndExpand(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
            
            var combinedResults: [MathValue] = []
            for l in leftResults {
                for r in rightResults {
                    combinedResults.append(try evaluateBinaryOperation(op: Token(type: .op("+"), rawValue: "+"), left: l, right: r))
                    combinedResults.append(try evaluateBinaryOperation(op: Token(type: .op("-"), rawValue: "-"), left: l, right: r))
                }
            }
            return (combinedResults, leftUsedAngle || rightUsedAngle)
        }
        
        let (result, nodeUsedAngle) = try _evaluateSingle(node: node, variables: &variables, functions: &functions, angleMode: angleMode)
        return ([result], nodeUsedAngle)
    }

    /// The core recursive function that evaluates a single node of the expression tree.
    func _evaluateSingle(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (result: MathValue, usedAngle: Bool) {
        var usedAngle = false
        
        switch node {
        case let numberNode as NumberNode:
            return (.dimensionless(numberNode.value), usedAngle)
        
        case let conversionNode as ConversionNode:
            let (sourceResult, sourceUsedAngle) = try _evaluateSingle(node: conversionNode.valueNode, variables: &variables, functions: &functions, angleMode: angleMode)
            let (targetResult, targetUsedAngle) = try _evaluateSingle(node: conversionNode.targetUnitNode, variables: &variables, functions: &functions, angleMode: angleMode)

            guard case .unitValue(var sourceUnitValue) = sourceResult else {
                throw MathError.typeMismatch(expected: "Value with units", found: sourceResult.typeName)
            }
            
            guard case .unitValue(let targetUnit) = targetResult else {
                throw MathError.typeMismatch(expected: "A target unit (e.g., .cm)", found: targetResult.typeName)
            }

            // Helper to recursively find the base unit symbol from the AST (e.g., 'm' from '.m^3')
            func findBaseSymbol(node: ExpressionNode) -> String? {
                if let unitNode = node as? UnitAndExponentNode {
                    return unitNode.unitSymbol
                }
                if let binaryNode = node as? BinaryOpNode {
                    // This handles implicit multiplication like `1 * .m^3`
                    return findBaseSymbol(node: binaryNode.right)
                }
                return nil
            }

            guard let symbol = findBaseSymbol(node: conversionNode.targetUnitNode) else {
                throw MathError.unknownConstant(name: "target unit for conversion")
            }
            
            guard sourceUnitValue.dimensions == targetUnit.dimensions else {
                throw MathError.dimensionMismatch(reason: "Cannot convert between incompatible units")
            }

            sourceUnitValue.preferredDisplayUnit = symbol
            
            return (.unitValue(sourceUnitValue), sourceUsedAngle || targetUsedAngle)

        case let unitNode as UnitAndExponentNode:
            guard let unitDef = UnitStore.units[unitNode.unitSymbol] else {
                throw MathError.unknownConstant(name: unitNode.unitSymbol)
            }

            var exponent = 1.0
            var expUsedAngle = false
            if let exponentNode = unitNode.exponent {
                let (expValue, usedAngle) = try _evaluateSingle(node: exponentNode, variables: &variables, functions: &functions, angleMode: angleMode)
                exponent = try expValue.asScalar()
                expUsedAngle = usedAngle
            }

            let finalConversionFactor = Foundation.pow(unitDef.conversionFactor, exponent)
            let finalDimensions = unitDef.dimensions.mapValues { Int(Double($0) * exponent) }.filter { $0.value != 0 }

            let resultUnitValue = UnitValue.create(value: finalConversionFactor, dimensions: finalDimensions)
            return (.unitValue(resultUnitValue), expUsedAngle)

        case let stringNode as StringNode:
            return (.constant(stringNode.value), false)
            
        case let constantNode as ConstantNode:
            if constantNode.name == "i" { return (.complex(Complex.i), usedAngle) }
            if let value = variables[constantNode.name] { return (value, usedAngle) }
            else if let value = Evaluator.siPrefixes[constantNode.name] { return (.dimensionless(value), usedAngle) }
            else if let value = Evaluator.constants[constantNode.name] { return (.dimensionless(value), usedAngle) }
            else { throw MathError.unknownConstant(name: constantNode.name) }
            
        case let assignmentNode as AssignmentNode:
            let (value, valueUsedAngle) = try evaluate(node: assignmentNode.expression, variables: &variables, functions: &functions, angleMode: angleMode)
            variables[assignmentNode.name] = value
            return (value, valueUsedAngle)

        case let funcDefNode as FunctionDefinitionNode:
            functions[funcDefNode.name] = funcDefNode
            return (.functionDefinition(funcDefNode.name), usedAngle)
            
        case let functionNode as FunctionCallNode:
            return try evaluateFunctionCall(functionNode, variables: &variables, functions: &functions, angleMode: angleMode)
            
        // --- MODIFIED: `uncert` function now supports units ---
        case let uncertNode as UncertaintyNode:
            let (value, _) = try _evaluateSingle(node: uncertNode.value, variables: &variables, functions: &functions, angleMode: angleMode)
            
            let nominalValue: Double
            let dimensions: UnitDimension
            switch value {
            case .dimensionless(let d):
                nominalValue = d
                dimensions = [:]
            case .unitValue(let u):
                nominalValue = u.value
                dimensions = u.dimensions
            default:
                throw MathError.typeMismatch(expected: "Numeric value for uncert", found: value.typeName)
            }

            var u_rand: Double = 0
            var u_sys_res: Double = 0
            var u_sys_acc: Double = 0
            
            for (name, expr) in uncertNode.namedArgs {
                let (argVal, _) = try _evaluateSingle(node: expr, variables: &variables, functions: &functions, angleMode: angleMode)
                
                let scalarArg: Double
                switch argVal {
                case .dimensionless(let d):
                    if !dimensions.isEmpty { throw MathError.dimensionMismatch(reason: "Uncertainty component must have same units as the value.") }
                    scalarArg = d
                case .unitValue(let u):
                    if u.dimensions != dimensions { throw MathError.dimensionMismatch(reason: "Uncertainty component must have same units as the value.") }
                    scalarArg = u.value
                default:
                    throw MathError.typeMismatch(expected: "Numeric value for uncertainty component", found: argVal.typeName)
                }
                
                switch name {
                case "random", "r":
                    u_rand = scalarArg
                case "resolution", "res":
                    u_sys_res = scalarArg / sqrt(12.0)
                case "accuracy", "a":
                    u_sys_acc = scalarArg / sqrt(3.0)
                default:
                    throw ParserError.invalidNamedArgument(function: "uncert", argument: name)
                }
            }
            
            let combinedSystematic = sqrt(pow(u_sys_res, 2) + pow(u_sys_acc, 2))
            
            let uncertainValue = UncertainValue(value: nominalValue, randomUncertainty: u_rand, systematicUncertainty: combinedSystematic, dimensions: dimensions)
            return (.uncertain(uncertainValue), false)

        case let vectorNode as VectorNode:
            var elements: [MathValue] = []
            for elementNode in vectorNode.elements {
                let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = usedAngle || elementUsedAngle
                elements.append(evaluatedElement)
            }
            let (values, commonDimension) = try extractValuesAndDimension(from: elements)
            return (.vector(Vector(values: values, dimensions: commonDimension)), usedAngle)

        case let matrixNode as MatrixNode:
            var allElements: [MathValue] = []
            for row in matrixNode.rows {
                for elementNode in row {
                    let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                    usedAngle = usedAngle || elementUsedAngle
                    allElements.append(evaluatedElement)
                }
            }
            let (values, commonDimension) = try extractValuesAndDimension(from: allElements)
            let rows = matrixNode.rows.count
            let columns = matrixNode.rows.first?.count ?? 0
            return (.matrix(Matrix(values: values, rows: rows, columns: columns, dimensions: commonDimension)), usedAngle)
            
        case let cVectorNode as ComplexVectorNode:
            var elements: [MathValue] = []
            for elementNode in cVectorNode.elements {
                let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = usedAngle || elementUsedAngle
                elements.append(evaluatedElement)
            }
            let (complexValues, commonDimension) = try extractComplexValuesAndDimension(from: elements)
            return (.complexVector(ComplexVector(values: complexValues, dimensions: commonDimension)), usedAngle)

        case let cMatrixNode as ComplexMatrixNode:
            var allElements: [MathValue] = []
            for row in cMatrixNode.rows {
                for elementNode in row {
                    let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                    usedAngle = usedAngle || elementUsedAngle
                    allElements.append(evaluatedElement)
                }
            }
            let (complexValues, commonDimension) = try extractComplexValuesAndDimension(from: allElements)
            let rows = cMatrixNode.rows.count
            let columns = cMatrixNode.rows.first?.count ?? 0
            return (.complexMatrix(ComplexMatrix(values: complexValues, rows: rows, columns: columns, dimensions: commonDimension)), usedAngle)

        case let unaryNode as UnaryOpNode:
            let (childValue, childUsedAngle) = try _evaluateSingle(node: unaryNode.child, variables: &variables, functions: &functions, angleMode: angleMode)
            let result = try evaluateUnaryOperation(op: unaryNode.op, value: childValue)
            return (result, childUsedAngle)
            
        case let postfixNode as PostfixOpNode:
             let (childValue, childUsedAngle) = try _evaluateSingle(node: postfixNode.child, variables: &variables, functions: &functions, angleMode: angleMode)
             let result = try evaluateUnaryOperation(op: postfixNode.op, value: childValue)
             return (result, childUsedAngle)

        case let binaryNode as BinaryOpNode:
            if binaryNode.op.rawValue == "∠" {
                let (rValue, rUsedAngle) = try _evaluateSingle(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
                let (thetaValue, thetaUsedAngle) = try _evaluateSingle(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = rUsedAngle || thetaUsedAngle
                guard case .dimensionless(let r) = rValue, case .dimensionless(let theta) = thetaValue else { throw MathError.typeMismatch(expected: "Dimensionless ∠ Dimensionless", found: "\(rValue.typeName) ∠ \(thetaValue.typeName)") }
                let thetaRad = angleMode == .degrees ? theta * .pi / 180.0 : theta
                return (.complex(Complex(real: r * cos(thetaRad), imaginary: r * sin(thetaRad))), true)
            }
            
            let (leftValue, leftUsedAngle) = try _evaluateSingle(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
            
            if let indexedOpNode = binaryNode.right as? IndexedOperationNode {
                return try evaluateIndexedAssignment(op: binaryNode.op, target: leftValue, indexedOp: indexedOpNode, variables: &variables, functions: &functions, angleMode: angleMode)
            }

            let (rightValue, rightUsedAngle) = try _evaluateSingle(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
            let result = try evaluateBinaryOperation(op: binaryNode.op, left: leftValue, right: rightValue)
            return (result, leftUsedAngle || rightUsedAngle)

        // --- MODIFIED: Handle units in derivative calculation ---
        case let derivativeNode as DerivativeNode:
            let (bodyNode, varName): (ExpressionNode, String)
            let pointNode = derivativeNode.point

            if let variableNode = derivativeNode.variable {
                bodyNode = derivativeNode.body
                varName = variableNode.name
            } else {
                let funcName: String
                if let funcNameNode = derivativeNode.body as? ConstantNode { funcName = funcNameNode.name }
                else if let funcCallNode = derivativeNode.body as? FunctionCallNode { funcName = funcCallNode.name }
                else { throw MathError.incorrectArgumentCount(function: "derivative", expected: "3 arguments (expression, variable, point) for this type of expression", found: 2) }
                
                guard let userFunction = functions[funcName] else { throw MathError.unknownFunction(name: funcName) }
                guard userFunction.parameterNames.count == 1 else { throw MathError.unsupportedOperation(op: "derivative", typeA: "function with \(userFunction.parameterNames.count) variables in 2-argument form", typeB: nil) }
                bodyNode = userFunction.body
                varName = userFunction.parameterNames[0]
            }

            let (pointValue, pointUsedAngle) = try _evaluateSingle(node: pointNode, variables: &variables, functions: &functions, angleMode: angleMode)
            let (orderValue, _) = try _evaluateSingle(node: derivativeNode.order, variables: &variables, functions: &functions, angleMode: angleMode)
            
            guard let pointUnitValue = pointValue.asUnitValue() else {
                 throw MathError.typeMismatch(expected: "A scalar value for the derivative point", found: pointValue.typeName)
            }

            guard case .dimensionless(let orderScalar) = orderValue, orderScalar >= 1, orderScalar.truncatingRemainder(dividingBy: 1) == 0 else { throw MathError.typeMismatch(expected: "Positive integer for derivative order", found: orderValue.typeName) }
            let order = Int(orderScalar)

            var tempVarsForDryRun = variables
            tempVarsForDryRun[varName] = .unitValue(pointUnitValue)
            let (_, bodyUsedAngle) = try _evaluateSingle(node: bodyNode, variables: &tempVarsForDryRun, functions: &functions, angleMode: angleMode)
            
            let result = try calculateNthDerivative(bodyNode: bodyNode, varName: varName, at: pointUnitValue, order: order, variables: &variables, functions: &functions, angleMode: angleMode)
            return (.unitValue(result), pointUsedAngle || bodyUsedAngle)

        // --- MODIFIED: Handle units in integral calculation ---
        case let integralNode as IntegralNode:
            let (lowerValue, lowerUsedAngle) = try _evaluateSingle(node: integralNode.lowerBound, variables: &variables, functions: &functions, angleMode: angleMode)
            let (upperValue, upperUsedAngle) = try _evaluateSingle(node: integralNode.upperBound, variables: &variables, functions: &functions, angleMode: angleMode)

            guard let a = lowerValue.asUnitValue(), let b = upperValue.asUnitValue() else {
                throw MathError.typeMismatch(expected: "Scalar values for integral bounds", found: "\(lowerValue.typeName) or \(upperValue.typeName)")
            }
            guard a.dimensions == b.dimensions else {
                throw MathError.dimensionMismatch(reason: "Integral bounds must have the same units.")
            }

            var bodyUsedAngle = false
            let f: (UnitValue) throws -> UnitValue = { x_unit in
                let (value, f_usedAngle) = try self.evaluateWithTempVar(
                    node: integralNode.body,
                    varName: integralNode.variable.name,
                    varValue: .unitValue(x_unit),
                    variables: &variables,
                    functions: &functions,
                    angleMode: angleMode
                )
                bodyUsedAngle = bodyUsedAngle || f_usedAngle
                guard let resultUnit = value.asUnitValue() else {
                    throw MathError.typeMismatch(expected: "A value with units from integral body", found: value.typeName)
                }
                return resultUnit
            }
                
            let tolerance = 1e-7
            let result = try adaptiveSimpson(f: f, a: a, b: b, tolerance: tolerance)
                    
            return (.unitValue(result), lowerUsedAngle || upperUsedAngle || bodyUsedAngle)

        // --- MODIFIED: Handle units in prime notation derivative ---
        case let primeNode as PrimeDerivativeNode:
            guard let userFunction = functions[primeNode.functionName] else {
                throw MathError.unknownFunction(name: primeNode.functionName)
            }
            guard userFunction.parameterNames.count == 1 else {
                throw MathError.incorrectArgumentCount(function: "\(primeNode.functionName)'", expected: "1", found: userFunction.parameterNames.count)
            }
            let varName = userFunction.parameterNames[0]

            let (pointValue, pointUsedAngle) = try _evaluateSingle(node: primeNode.argument, variables: &variables, functions: &functions, angleMode: angleMode)
            
            guard let pointUnitValue = pointValue.asUnitValue() else {
                throw MathError.typeMismatch(expected: "A scalar value for the derivative point", found: pointValue.typeName)
            }

            var tempVars = variables
            tempVars[varName] = .unitValue(pointUnitValue)
            let (_, bodyUsedAngle) = try _evaluateSingle(node: userFunction.body, variables: &tempVars, functions: &functions, angleMode: angleMode)
            
            let h_unit = UnitValue(value: h, dimensions: pointUnitValue.dimensions)

            let valPlus_Math = try evaluateWithTempVar(node: userFunction.body, varName: varName, varValue: .unitValue(try pointUnitValue + h_unit), variables: &variables, functions: &functions, angleMode: angleMode).result
            let valMinus_Math = try evaluateWithTempVar(node: userFunction.body, varName: varName, varValue: .unitValue(try pointUnitValue - h_unit), variables: &variables, functions: &functions, angleMode: angleMode).result
            
            guard let valPlus = valPlus_Math.asUnitValue(), let valMinus = valMinus_Math.asUnitValue() else {
                throw MathError.typeMismatch(expected: "A value with units for derivative calculation", found: "\(valPlus_Math.typeName) or \(valMinus_Math.typeName)")
            }

            let numerator = try valPlus - valMinus
            let denominator = UnitValue(value: 2 * h, dimensions: pointUnitValue.dimensions)
            let derivative = try numerator / denominator
            
            return (.unitValue(derivative), pointUsedAngle || bodyUsedAngle)
            
        case let autoplotNode as AutoplotNode:
            return try (evaluateAutoplot(autoplotNode, variables: &variables, functions: &functions), false)
            
        case let plotNode as PlotNode:
            return try (evaluatePlot(plotNode, variables: &variables, functions: &functions), false)

        case let scatterNode as ScatterplotNode:
            return try (evaluateScatterplot(scatterNode, variables: &variables, functions: &functions), false)

        case let solveNode as SolveNode:
            return try evaluateSolve(solveNode, variables: &variables, functions: &functions, angleMode: angleMode)

        case is ImportCSVNode:
            return (.triggerCSVImport, false)

        default:
            throw MathError.invalidNode
        }
    }
}

// --- FIX: Helper function to build a unit-aware Vector/Matrix ---
/// Extracts numeric values and a common unit dimension from a list of MathValues.
/// This version allows dimensionless values (especially zero) to conform to the vector's unit type.
private func extractValuesAndDimension(from elements: [MathValue]) throws -> (values: [Double], dimensions: UnitDimension) {
    guard !elements.isEmpty else {
        return ([], [:])
    }
    
    var commonDimension: UnitDimension? = nil
    // First pass: find a non-dimensionless unit to establish the vector's unit type.
    for element in elements {
        if case .unitValue(let u) = element, !u.dimensions.isEmpty {
            commonDimension = u.dimensions
            break
        }
    }
    // If no element with units was found, the vector is dimensionless.
    let finalDimension = commonDimension ?? [:]
    
    var values: [Double] = []
    for element in elements {
        switch element {
        case .dimensionless(let d):
            values.append(d)
        case .unitValue(let u):
            // An element is compatible if its dimension matches the vector's,
            // or if the element is dimensionless (it can adopt the vector's unit).
            if u.dimensions == finalDimension {
                values.append(u.value)
            } else if u.dimensions.isEmpty {
                 values.append(u.value)
            } else if finalDimension.isEmpty {
                // This occurs if the first element had units, but a later one is dimensionless
                throw MathError.dimensionMismatch(reason: "All elements in a vector or matrix must have the same units.")
            } else {
                 throw MathError.dimensionMismatch(reason: "All elements in a vector or matrix must have the same units.")
            }
        default:
            throw MathError.typeMismatch(expected: "Numeric value (with or without units)", found: element.typeName)
        }
    }
    
    return (values, finalDimension)
}

// --- FIX: Helper function to build a unit-aware ComplexVector/ComplexMatrix ---
/// Extracts complex values and a common unit dimension, allowing dimensionless values to conform.
private func extractComplexValuesAndDimension(from elements: [MathValue]) throws -> (values: [Complex], dimensions: UnitDimension) {
    guard !elements.isEmpty else {
        return ([], [:])
    }
    
    var commonDimension: UnitDimension? = nil
    // First pass to find a non-dimensionless unit.
    for element in elements {
        if case .unitValue(let u) = element, !u.dimensions.isEmpty {
            commonDimension = u.dimensions
            break
        }
    }
    let finalDimension = commonDimension ?? [:]
    
    var values: [Complex] = []
    for element in elements {
        let currentDimension: UnitDimension
        let currentValue: Complex
        
        switch element {
        case .dimensionless(let d):
            currentValue = Complex(real: d, imaginary: 0)
            currentDimension = [:]
        case .unitValue(let u):
            currentValue = Complex(real: u.value, imaginary: 0)
            currentDimension = u.dimensions
        case .complex(let c):
            currentValue = c
            currentDimension = [:] // Complex numbers are inherently dimensionless in this system
        default:
            throw MathError.typeMismatch(expected: "Numeric or Complex value", found: element.typeName)
        }
        
        if currentDimension == finalDimension || currentDimension.isEmpty {
            values.append(currentValue)
        } else if finalDimension.isEmpty {
            throw MathError.dimensionMismatch(reason: "All elements in a complex vector or matrix must have the same units.")
        } else {
            throw MathError.dimensionMismatch(reason: "All elements in a complex vector or matrix must have the same units.")
        }
    }
    
    return (values, finalDimension)
}
