import Foundation

enum MathError: Error, CustomStringConvertible {
    case divisionByZero
    case unknownOperator(op: String)
    case unknownConstant(name: String)
    case unknownFunction(name: String)
    case invalidNode
    case typeMismatch(expected: String, found: String)
    case unsupportedOperation(op: String, typeA: String, typeB: String?)
    case dimensionMismatch(reason: String)
    case incorrectArgumentCount(function: String, expected: String, found: Int)
    case requiresAtLeastOneArgument(function: String)
    case plotError(reason: String)
    case unitConversionError(from: String, to: String)

    var description: String {
        switch self {
        case .divisionByZero: return "Error: Division by zero."
        case .unknownOperator(let op): return "Error: Unknown operator '\(op)'."
        case .unknownConstant(let name): return "Error: Unknown constant or unit '\(name)'."
        case .unknownFunction(let name): return "Error: Unknown function '\(name)'."
        case .invalidNode: return "Error: The expression tree contains an invalid node."
        case .typeMismatch(let expected, let found): return "Error: Type mismatch. Expected \(expected), but found \(found)."
        case .unsupportedOperation(let op, let typeA, let typeB):
            if let typeB = typeB {
                if typeA == "Tuple" && typeB == "Tuple" {
                    return "Error: Operations between two multi-valued results are not supported."
                }
                return "Error: Operator '\(op)' is not supported between \(typeA) and \(typeB)."
            }
            if typeA == "hyp < side" { return "Error: Hypotenuse must be greater than or equal to the side." }
            if typeA == "Singular Matrix" { return "Error: Matrix is singular and cannot be inverted."}
            return "Error: Operator '\(op)' is not supported for \(typeA)."
        case .dimensionMismatch(let reason): return "Error: Dimension mismatch. \(reason)."
        case .incorrectArgumentCount(let function, let expected, let found): return "Error: Function '\(function)' expects \(expected) argument(s), but received \(found)."
        case .requiresAtLeastOneArgument(let function): return "Error: Function '\(function)' requires at least one argument."
        case .plotError(let reason): return "Plot Error: \(reason)."
        case .unitConversionError(let from, let to): return "Error: Cannot convert from \(from) to \(to). Units must have the same physical dimension."
        }
    }
}

/// The core evaluation engine. This struct contains the main recursive evaluation loop (`_evaluateSingle`)
/// that traverses the abstract syntax tree (AST) generated by the Parser.
struct Evaluator {

    let h = 1e-5 // A small step size for numerical differentiation

    /// A helper function to evaluate an expression with a temporary variable, used for calculus operations.
    func evaluateWithTempVar(node: ExpressionNode, varName: String, varValue: Double, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> MathValue {
        var tempVars = variables
        tempVars[varName] = .dimensionless(varValue)
        let (result, _) = try _evaluateSingle(node: node, variables: &tempVars, functions: &functions, angleMode: angleMode)
        return result
    }
    
    /// The main entry point for evaluating an expression node. It handles expanding multi-value results (from `±`).
    func evaluate(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (result: MathValue, usedAngle: Bool) {
        let (results, usedAngle) = try evaluateAndExpand(node: node, variables: &variables, functions: &functions, angleMode: angleMode)
        if results.count == 1 {
            return (results[0], usedAngle)
        } else {
            return (.tuple(results), usedAngle)
        }
    }
    
    /// Recursively evaluates an expression, handling the `±` operator by creating multiple evaluation paths.
    private func evaluateAndExpand(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (results: [MathValue], usedAngle: Bool) {
        if let binaryNode = node as? BinaryOpNode, binaryNode.op.rawValue == "±" {
            let (leftResults, leftUsedAngle) = try evaluateAndExpand(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
            let (rightResults, rightUsedAngle) = try evaluateAndExpand(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
            
            var combinedResults: [MathValue] = []
            for l in leftResults {
                for r in rightResults {
                    combinedResults.append(try evaluateBinaryOperation(op: Token(type: .op("+"), rawValue: "+"), left: l, right: r))
                    combinedResults.append(try evaluateBinaryOperation(op: Token(type: .op("-"), rawValue: "-"), left: l, right: r))
                }
            }
            return (combinedResults, leftUsedAngle || rightUsedAngle)
        }
        
        let (result, nodeUsedAngle) = try _evaluateSingle(node: node, variables: &variables, functions: &functions, angleMode: angleMode)
        return ([result], nodeUsedAngle)
    }

    /// The core recursive function that evaluates a single node of the expression tree.
    func _evaluateSingle(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (result: MathValue, usedAngle: Bool) {
        var usedAngle = false
        
        switch node {
        case let numberNode as NumberNode:
            return (.dimensionless(numberNode.value), usedAngle)
        
        case let conversionNode as ConversionNode:
            let (sourceResult, sourceUsedAngle) = try _evaluateSingle(node: conversionNode.valueNode, variables: &variables, functions: &functions, angleMode: angleMode)
            
            guard let targetUnitNode = conversionNode.targetUnitNode as? BinaryOpNode,
                  let unitAndExpNode = targetUnitNode.right as? UnitAndExponentNode,
                  let numberNode = targetUnitNode.left as? NumberNode,
                  numberNode.value == 1.0,
                  unitAndExpNode.exponent == nil else {
                throw MathError.typeMismatch(expected: "a simple unit (e.g., .cm)", found: "a complex expression")
            }
            
            let targetUnitSymbol = unitAndExpNode.unitSymbol
            
            guard let targetUnitDef = UnitStore.units[targetUnitSymbol] else {
                throw MathError.unknownConstant(name: targetUnitSymbol)
            }

            guard case .unitValue(var sourceUnitValue) = sourceResult else {
                throw MathError.typeMismatch(expected: "Value with units", found: sourceResult.typeName)
            }

            guard sourceUnitValue.dimensions == targetUnitDef.dimensions else {
                throw MathError.dimensionMismatch(reason: "Cannot convert between incompatible units")
            }

            sourceUnitValue.preferredDisplayUnit = targetUnitSymbol
            
            return (.unitValue(sourceUnitValue), sourceUsedAngle)

        // FIX: Added a new case to handle the unit-with-exponent node.
        case let unitNode as UnitAndExponentNode:
            guard let unitDef = UnitStore.units[unitNode.unitSymbol] else {
                throw MathError.unknownConstant(name: unitNode.unitSymbol)
            }

            var exponent = 1.0
            var expUsedAngle = false
            if let exponentNode = unitNode.exponent {
                let (expValue, usedAngle) = try _evaluateSingle(node: exponentNode, variables: &variables, functions: &functions, angleMode: angleMode)
                exponent = try expValue.asScalar()
                expUsedAngle = usedAngle
            }

            // The conversion factor and dimensions are adjusted by the exponent.
            let finalConversionFactor = Foundation.pow(unitDef.conversionFactor, exponent)
            let finalDimensions = unitDef.dimensions.mapValues { Int(Double($0) * exponent) }.filter { $0.value != 0 }

            // This node evaluates to a UnitValue with a numeric value of its conversion factor,
            // ready to be multiplied by the actual number.
            let resultUnitValue = UnitValue(value: finalConversionFactor, dimensions: finalDimensions)
            return (.unitValue(resultUnitValue), expUsedAngle)

        case let stringNode as StringNode:
            return (.constant(stringNode.value), false)
            
        case let constantNode as ConstantNode:
            if constantNode.name == "i" { return (.complex(Complex.i), usedAngle) }
            if let value = variables[constantNode.name] { return (value, usedAngle) }
            else if let value = Evaluator.siPrefixes[constantNode.name] { return (.dimensionless(value), usedAngle) }
            else if let value = Evaluator.constants[constantNode.name] { return (.dimensionless(value), usedAngle) }
            else { throw MathError.unknownConstant(name: constantNode.name) }
            
        case let assignmentNode as AssignmentNode:
            let (value, valueUsedAngle) = try evaluate(node: assignmentNode.expression, variables: &variables, functions: &functions, angleMode: angleMode)
            variables[assignmentNode.name] = value
            return (value, valueUsedAngle)

        case let funcDefNode as FunctionDefinitionNode:
            functions[funcDefNode.name] = funcDefNode
            return (.functionDefinition(funcDefNode.name), usedAngle)
            
        case let functionNode as FunctionCallNode:
            return try evaluateFunctionCall(functionNode, variables: &variables, functions: &functions, angleMode: angleMode)
            
        case let uncertNode as UncertaintyNode:
            let (value, _) = try _evaluateSingle(node: uncertNode.value, variables: &variables, functions: &functions, angleMode: angleMode)
            let nominalValue = try value.asScalar()
            
            var u_rand: Double = 0
            var u_sys_res: Double = 0
            var u_sys_acc: Double = 0
            
            for (name, expr) in uncertNode.namedArgs {
                let (argVal, _) = try _evaluateSingle(node: expr, variables: &variables, functions: &functions, angleMode: angleMode)
                let scalarArg = try argVal.asScalar()
                
                switch name {
                case "random", "r":
                    u_rand = scalarArg
                case "resolution", "res":
                    u_sys_res = scalarArg / sqrt(12.0)
                case "accuracy", "a":
                    u_sys_acc = scalarArg / sqrt(3.0)
                default:
                    throw ParserError.invalidNamedArgument(function: "uncert", argument: name)
                }
            }
            
            let combinedSystematic = sqrt(pow(u_sys_res, 2) + pow(u_sys_acc, 2))
            
            let uncertainValue = UncertainValue(value: nominalValue, randomUncertainty: u_rand, systematicUncertainty: combinedSystematic)
            return (.uncertain(uncertainValue), false)

        case let vectorNode as VectorNode:
            var elements: [Double] = []
            for elementNode in vectorNode.elements {
                let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = usedAngle || elementUsedAngle
                elements.append(try evaluatedElement.asScalar())
            }
            return (.vector(Vector(values: elements)), usedAngle)
            
        case let matrixNode as MatrixNode:
            var values: [Double] = []
            let rows = matrixNode.rows.count; let columns = matrixNode.rows.first?.count ?? 0
            for row in matrixNode.rows {
                for elementNode in row {
                    let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                    usedAngle = usedAngle || elementUsedAngle
                    values.append(try evaluatedElement.asScalar())
                }
            }
            return (.matrix(Matrix(values: values, rows: rows, columns: columns)), usedAngle)

        case let cVectorNode as ComplexVectorNode:
            var elements: [Complex] = []
            for elementNode in cVectorNode.elements {
                let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = usedAngle || elementUsedAngle
                switch evaluatedElement {
                case .complex(let c): elements.append(c)
                case .dimensionless(let s): elements.append(Complex(real: s, imaginary: 0))
                default: throw MathError.typeMismatch(expected: "Complex or Dimensionless", found: evaluatedElement.typeName)
                }
            }
            return (.complexVector(ComplexVector(values: elements)), usedAngle)

        case let cMatrixNode as ComplexMatrixNode:
            var values: [Complex] = []; let rows = cMatrixNode.rows.count; let columns = cMatrixNode.rows.first?.count ?? 0
            for row in cMatrixNode.rows {
                for elementNode in row {
                    let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                    usedAngle = usedAngle || elementUsedAngle
                    switch evaluatedElement {
                    case .complex(let c): values.append(c)
                    case .dimensionless(let s): values.append(Complex(real: s, imaginary: 0))
                    default: throw MathError.typeMismatch(expected: "Complex or Dimensionless", found: evaluatedElement.typeName)
                    }
                }
            }
            return (.complexMatrix(ComplexMatrix(values: values, rows: rows, columns: columns)), usedAngle)

        case let unaryNode as UnaryOpNode:
            let (childValue, childUsedAngle) = try _evaluateSingle(node: unaryNode.child, variables: &variables, functions: &functions, angleMode: angleMode)
            let result = try evaluateUnaryOperation(op: unaryNode.op, value: childValue)
            return (result, childUsedAngle)
            
        case let postfixNode as PostfixOpNode:
             let (childValue, childUsedAngle) = try _evaluateSingle(node: postfixNode.child, variables: &variables, functions: &functions, angleMode: angleMode)
             let result = try evaluateUnaryOperation(op: postfixNode.op, value: childValue)
             return (result, childUsedAngle)

        case let binaryNode as BinaryOpNode:
            if binaryNode.op.rawValue == "∠" {
                let (rValue, rUsedAngle) = try _evaluateSingle(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
                let (thetaValue, thetaUsedAngle) = try _evaluateSingle(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = rUsedAngle || thetaUsedAngle
                guard case .dimensionless(let r) = rValue, case .dimensionless(let theta) = thetaValue else { throw MathError.typeMismatch(expected: "Dimensionless ∠ Dimensionless", found: "\(rValue.typeName) ∠ \(thetaValue.typeName)") }
                let thetaRad = angleMode == .degrees ? theta * .pi / 180.0 : theta
                return (.complex(Complex(real: r * cos(thetaRad), imaginary: r * sin(thetaRad))), true)
            }
            
            let (leftValue, leftUsedAngle) = try _evaluateSingle(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
            
            if let indexedOpNode = binaryNode.right as? IndexedOperationNode {
                return try evaluateIndexedAssignment(op: binaryNode.op, target: leftValue, indexedOp: indexedOpNode, variables: &variables, functions: &functions, angleMode: angleMode)
            }

            let (rightValue, rightUsedAngle) = try _evaluateSingle(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
            let result = try evaluateBinaryOperation(op: binaryNode.op, left: leftValue, right: rightValue)
            return (result, leftUsedAngle || rightUsedAngle)

        case let derivativeNode as DerivativeNode:
            let (bodyNode, varName): (ExpressionNode, String)
            let pointNode = derivativeNode.point

            if let variableNode = derivativeNode.variable {
                bodyNode = derivativeNode.body
                varName = variableNode.name
            } else {
                let funcName: String
                if let funcNameNode = derivativeNode.body as? ConstantNode {
                    funcName = funcNameNode.name
                } else if let funcCallNode = derivativeNode.body as? FunctionCallNode {
                    funcName = funcCallNode.name
                } else {
                    throw MathError.incorrectArgumentCount(function: "derivative", expected: "3 arguments (expression, variable, point) for this type of expression", found: 2)
                }
                
                guard let userFunction = functions[funcName] else { throw MathError.unknownFunction(name: funcName) }
                guard userFunction.parameterNames.count == 1 else { throw MathError.unsupportedOperation(op: "derivative", typeA: "function with \(userFunction.parameterNames.count) variables in 2-argument form", typeB: nil) }
                bodyNode = userFunction.body
                varName = userFunction.parameterNames[0]
            }

            let (pointValue, pointUsedAngle) = try _evaluateSingle(node: pointNode, variables: &variables, functions: &functions, angleMode: angleMode)
            let (orderValue, _) = try _evaluateSingle(node: derivativeNode.order, variables: &variables, functions: &functions, angleMode: angleMode)

            let point = try pointValue.asScalar()
            guard case .dimensionless(let orderScalar) = orderValue, orderScalar >= 1, orderScalar.truncatingRemainder(dividingBy: 1) == 0 else { throw MathError.typeMismatch(expected: "Positive integer for derivative order", found: orderValue.typeName) }
            let order = Int(orderScalar)

            var tempVarsForDryRun = variables
            tempVarsForDryRun[varName] = .dimensionless(0)
            let bodyUsedAngle = (try? _evaluateSingle(node: bodyNode, variables: &tempVarsForDryRun, functions: &functions, angleMode: angleMode))?.usedAngle ?? false
            
            let result = try calculateNthDerivative(bodyNode: bodyNode, varName: varName, at: point, order: order, variables: &variables, functions: &functions, angleMode: angleMode)
            return (.dimensionless(result), pointUsedAngle || bodyUsedAngle)

        case let integralNode as IntegralNode:
            let (lowerValue, lowerUsedAngle) = try _evaluateSingle(node: integralNode.lowerBound, variables: &variables, functions: &functions, angleMode: angleMode)
            let (upperValue, upperUsedAngle) = try _evaluateSingle(node: integralNode.upperBound, variables: &variables, functions: &functions, angleMode: angleMode)

            let a = try lowerValue.asScalar()
            let b = try upperValue.asScalar()

            var tempVarsForDryRun = variables
            tempVarsForDryRun[integralNode.variable.name] = .dimensionless(0)
            let bodyUsedAngle = (try? _evaluateSingle(node: integralNode.body, variables: &tempVarsForDryRun, functions: &functions, angleMode: angleMode))?.usedAngle ?? false

            let f: (Double) throws -> Double = { x in
                var localVars = variables
                var localFuncs = functions
                let value = try self.evaluateWithTempVar(
                    node: integralNode.body,
                    varName: integralNode.variable.name,
                    varValue: x,
                    variables: &localVars,
                    functions: &localFuncs,
                    angleMode: angleMode
                )
                return try value.asScalar()
            }
                
            let tolerance = 1e-7
            let result = try adaptiveSimpson(f: f, a: a, b: b, tolerance: tolerance)
                    
            return (.dimensionless(result), lowerUsedAngle || upperUsedAngle || bodyUsedAngle)

        case let primeNode as PrimeDerivativeNode:
            guard let userFunction = functions[primeNode.functionName] else {
                throw MathError.unknownFunction(name: primeNode.functionName)
            }
            guard userFunction.parameterNames.count == 1 else {
                throw MathError.incorrectArgumentCount(function: "\(primeNode.functionName)'", expected: "1", found: userFunction.parameterNames.count)
            }
            let varName = userFunction.parameterNames[0]

            let (pointValue, pointUsedAngle) = try _evaluateSingle(node: primeNode.argument, variables: &variables, functions: &functions, angleMode: angleMode)
            let point = try pointValue.asScalar()

            var tempVars = variables
            tempVars[varName] = .dimensionless(point)
            let bodyUsedAngle = (try? _evaluateSingle(node: userFunction.body, variables: &tempVars, functions: &functions, angleMode: angleMode))?.usedAngle ?? false

            let valPlus = try evaluateWithTempVar(node: userFunction.body, varName: varName, varValue: point + h, variables: &variables, functions: &functions, angleMode: angleMode)
            let valMinus = try evaluateWithTempVar(node: userFunction.body, varName: varName, varValue: point - h, variables: &variables, functions: &functions, angleMode: angleMode)
            
            let scalarPlus = try valPlus.asScalar()
            let scalarMinus = try valMinus.asScalar()

            let derivative = (scalarPlus - scalarMinus) / (2 * h)
            return (.dimensionless(derivative), pointUsedAngle || bodyUsedAngle)
            
        case let autoplotNode as AutoplotNode:
            return try (evaluateAutoplot(autoplotNode, variables: &variables, functions: &functions), false)
            
        case let plotNode as PlotNode:
            return try (evaluatePlot(plotNode, variables: &variables, functions: &functions), false)

        case let scatterNode as ScatterplotNode:
            return try (evaluateScatterplot(scatterNode, variables: &variables, functions: &functions), false)

        case is ImportCSVNode:
            return (.triggerCSVImport, false)

        default:
            throw MathError.invalidNode
        }
    }
}

