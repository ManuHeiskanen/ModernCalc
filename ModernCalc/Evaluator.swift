import Foundation

enum MathError: Error, CustomStringConvertible {
    case divisionByZero
    case unknownOperator(op: String)
    case unknownConstant(name: String)
    case unknownFunction(name: String)
    case invalidNode
    case typeMismatch(expected: String, found: String)
    case unsupportedOperation(op: String, typeA: String, typeB: String?)
    case dimensionMismatch(reason: String)
    case incorrectArgumentCount(function: String, expected: String, found: Int)
    case requiresAtLeastOneArgument(function: String)
    case plotError(reason: String)
    case unitConversionError(from: String, to: String)
    case solverFailed(reason: String)

    var description: String {
        switch self {
        case .divisionByZero: return "Error: Division by zero."
        case .unknownOperator(let op): return "Error: Unknown operator '\(op)'."
        case .unknownConstant(let name): return "Error: Unknown constant or unit '\(name)'."
        case .unknownFunction(let name): return "Error: Unknown function '\(name)'."
        case .invalidNode: return "Error: The expression tree contains an invalid node."
        case .typeMismatch(let expected, let found): return "Error: Type mismatch. Expected \(expected), but found \(found)."
        case .unsupportedOperation(let op, let typeA, let typeB):
            if let typeB = typeB {
                if typeA == "Tuple" && typeB == "Tuple" {
                    return "Error: Operations between two multi-valued results are not supported."
                }
                return "Error: Operator '\(op)' is not supported between \(typeA) and \(typeB)."
            }
            if typeA == "hyp < side" { return "Error: Hypotenuse must be greater than or equal to the side." }
            if typeA == "Singular Matrix" { return "Error: Matrix is singular and cannot be inverted."}
            return "Error: Operator '\(op)' is not supported for \(typeA)."
        case .dimensionMismatch(let reason): return "Error: Dimension mismatch. \(reason)."
        case .incorrectArgumentCount(let function, let expected, let found): return "Error: Function '\(function)' expects \(expected) argument(s), but received \(found)."
        case .requiresAtLeastOneArgument(let function): return "Error: Function '\(function)' requires at least one argument."
        case .plotError(let reason): return "Plot Error: \(reason)."
        case .unitConversionError(let from, let to): return "Error: Cannot convert from \(from) to \(to). Units must have the same physical dimension."
        case .solverFailed(let reason): return "Solver Error: \(reason)."
        }
    }
}

/// The core evaluation engine. This struct contains the main recursive evaluation loop (`_evaluateSingle`)
/// that traverses the abstract syntax tree (AST) generated by the Parser.
struct Evaluator {

    let h = 1e-5 // A small step size for numerical differentiation

    /// A helper function to evaluate an expression with a temporary variable, used for calculus operations.
    func evaluateWithTempVar(node: ExpressionNode, varName: String, varValue: MathValue, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (result: MathValue, usedAngle: Bool) {
        var tempVars = variables
        tempVars[varName] = varValue
        let (result, usedAngle) = try _evaluateSingle(node: node, variables: &tempVars, functions: &functions, angleMode: angleMode)
        return (result, usedAngle)
    }
    
    /// The main entry point for evaluating an expression node. It handles expanding multi-value results (from `±`).
    func evaluate(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (result: MathValue, usedAngle: Bool) {
        let (results, usedAngle) = try evaluateAndExpand(node: node, variables: &variables, functions: &functions, angleMode: angleMode)
        if results.count == 1 {
            return (results[0], usedAngle)
        } else {
            return (.tuple(results), usedAngle)
        }
    }
    
    /// Recursively evaluates an expression, handling the `±` operator by creating multiple evaluation paths.
    private func evaluateAndExpand(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (results: [MathValue], usedAngle: Bool) {
        if let binaryNode = node as? BinaryOpNode, binaryNode.op.rawValue == "±" {
            let (leftResults, leftUsedAngle) = try evaluateAndExpand(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
            let (rightResults, rightUsedAngle) = try evaluateAndExpand(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
            
            var combinedResults: [MathValue] = []
            for l in leftResults {
                for r in rightResults {
                    combinedResults.append(try evaluateBinaryOperation(op: Token(type: .op("+"), rawValue: "+"), left: l, right: r))
                    combinedResults.append(try evaluateBinaryOperation(op: Token(type: .op("-"), rawValue: "-"), left: l, right: r))
                }
            }
            return (combinedResults, leftUsedAngle || rightUsedAngle)
        }
        
        let (result, nodeUsedAngle) = try _evaluateSingle(node: node, variables: &variables, functions: &functions, angleMode: angleMode)
        return ([result], nodeUsedAngle)
    }

    /// The core recursive function that evaluates a single node of the expression tree.
    func _evaluateSingle(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (result: MathValue, usedAngle: Bool) {
        var usedAngle = false
        
        switch node {
        case let numberNode as NumberNode:
            return (.dimensionless(numberNode.value), usedAngle)
        
        case let conversionNode as ConversionNode:
            let (sourceResult, sourceUsedAngle) = try _evaluateSingle(node: conversionNode.valueNode, variables: &variables, functions: &functions, angleMode: angleMode)
            let (targetResult, targetUsedAngle) = try _evaluateSingle(node: conversionNode.targetUnitNode, variables: &variables, functions: &functions, angleMode: angleMode)

            guard case .unitValue(var sourceUnitValue) = sourceResult else {
                throw MathError.typeMismatch(expected: "Value with units", found: sourceResult.typeName)
            }
            
            guard case .unitValue(let targetUnit) = targetResult else {
                throw MathError.typeMismatch(expected: "A target unit (e.g., .cm)", found: targetResult.typeName)
            }

            // Helper to recursively find the base unit symbol from the AST (e.g., 'm' from '.m^3')
            func findBaseSymbol(node: ExpressionNode) -> String? {
                if let unitNode = node as? UnitAndExponentNode {
                    return unitNode.unitSymbol
                }
                if let binaryNode = node as? BinaryOpNode {
                    // This handles implicit multiplication like `1 * .m^3`
                    return findBaseSymbol(node: binaryNode.right)
                }
                return nil
            }

            guard let symbol = findBaseSymbol(node: conversionNode.targetUnitNode) else {
                throw MathError.unknownConstant(name: "target unit for conversion")
            }
            
            guard sourceUnitValue.dimensions == targetUnit.dimensions else {
                throw MathError.dimensionMismatch(reason: "Cannot convert between incompatible units")
            }

            sourceUnitValue.preferredDisplayUnit = symbol
            
            return (.unitValue(sourceUnitValue), sourceUsedAngle || targetUsedAngle)

        case let unitNode as UnitAndExponentNode:
            guard let unitDef = UnitStore.units[unitNode.unitSymbol] else {
                throw MathError.unknownConstant(name: unitNode.unitSymbol)
            }

            var exponent = 1.0
            var expUsedAngle = false
            if let exponentNode = unitNode.exponent {
                let (expValue, usedAngle) = try _evaluateSingle(node: exponentNode, variables: &variables, functions: &functions, angleMode: angleMode)
                exponent = try expValue.asScalar()
                expUsedAngle = usedAngle
            }

            let finalConversionFactor = Foundation.pow(unitDef.conversionFactor, exponent)
            let finalDimensions = unitDef.dimensions.mapValues { Int(Double($0) * exponent) }.filter { $0.value != 0 }

            let resultUnitValue = UnitValue.create(value: finalConversionFactor, dimensions: finalDimensions)
            return (.unitValue(resultUnitValue), expUsedAngle)

        case let stringNode as StringNode:
            return (.constant(stringNode.value), false)
            
        case let constantNode as ConstantNode:
            if constantNode.name == "i" { return (.complex(Complex.i), usedAngle) }
            if let value = variables[constantNode.name] { return (value, usedAngle) }
            else if let value = Evaluator.siPrefixes[constantNode.name] { return (.dimensionless(value), usedAngle) }
            else if let value = Evaluator.constants[constantNode.name] { return (.dimensionless(value), usedAngle) }
            // 'end' is a special keyword for indexing, it shouldn't be evaluated here.
            // It will be handled inside evaluateIndexAccess. If it reaches here, it's an error.
            else if constantNode.name == "end" {
                throw MathError.unsupportedOperation(op: "end", typeA: "Keyword 'end' can only be used inside matrix/vector indexing.", typeB: nil)
            }
            else { throw MathError.unknownConstant(name: constantNode.name) }
            
        case let assignmentNode as AssignmentNode:
            let (value, valueUsedAngle) = try evaluate(node: assignmentNode.expression, variables: &variables, functions: &functions, angleMode: angleMode)
            variables[assignmentNode.name] = value
            return (value, valueUsedAngle)

        case let funcDefNode as FunctionDefinitionNode:
            functions[funcDefNode.name] = funcDefNode
            return (.functionDefinition(funcDefNode.name), usedAngle)
            
        case let functionNode as FunctionCallNode:
            // --- FIX: Check if this is an index access operation before treating it as a function call ---
            if let targetValue = variables[functionNode.name] {
                switch targetValue {
                case .matrix, .vector, .complexMatrix, .complexVector:
                    // It's a variable that can be indexed, so treat it as an index access.
                    return try evaluateIndexAccess(target: targetValue, argNodes: functionNode.arguments, variables: &variables, functions: &functions, angleMode: angleMode)
                default:
                    // It's some other type of variable, so it can't be indexed. Fall through to treat as a function call.
                    break
                }
            }
            // If no variable with this name exists, it must be a function call.
            return try evaluateFunctionCall(functionNode, variables: &variables, functions: &functions, angleMode: angleMode)
            
        case let uncertNode as UncertaintyNode:
            let (value, _) = try _evaluateSingle(node: uncertNode.value, variables: &variables, functions: &functions, angleMode: angleMode)
            
            let nominalValue: Double
            let dimensions: UnitDimension
            switch value {
            case .dimensionless(let d):
                nominalValue = d
                dimensions = [:]
            case .unitValue(let u):
                nominalValue = u.value
                dimensions = u.dimensions
            default:
                throw MathError.typeMismatch(expected: "Numeric value for uncert", found: value.typeName)
            }

            var u_rand: Double = 0
            var u_sys_res: Double = 0
            var u_sys_acc: Double = 0
            var u_sys_direct: Double = 0
            
            for (name, expr) in uncertNode.namedArgs {
                let (argVal, _) = try _evaluateSingle(node: expr, variables: &variables, functions: &functions, angleMode: angleMode)
                
                let scalarArg: Double
                switch argVal {
                case .dimensionless(let d):
                    scalarArg = d // Allow dimensionless uncertainty, assume same units as nominal value
                case .unitValue(let u):
                    if u.dimensions != dimensions { // If units ARE provided, they must match
                        throw MathError.dimensionMismatch(reason: "Uncertainty component must have same units as the value")
                    }
                    scalarArg = u.value
                default:
                    throw MathError.typeMismatch(expected: "Numeric value for uncertainty component", found: argVal.typeName)
                }
                
                switch name {
                case "random", "r":
                    u_rand = scalarArg
                case "resolution", "res":
                    u_sys_res = scalarArg / sqrt(12.0)
                case "accuracy", "a":
                    u_sys_acc = scalarArg / sqrt(3.0)
                case "systematic", "s":
                    u_sys_direct = scalarArg
                default:
                    throw ParserError.invalidNamedArgument(function: "uncert", argument: name)
                }
            }
            
            let combinedSystematic = sqrt(pow(u_sys_res, 2) + pow(u_sys_acc, 2) + pow(u_sys_direct, 2))
            
            let uncertainValue = UncertainValue(value: nominalValue, randomUncertainty: u_rand, systematicUncertainty: combinedSystematic, dimensions: dimensions)
            return (.uncertain(uncertainValue), false)

        case let vectorNode as VectorNode:
            var elements: [MathValue] = []
            for elementNode in vectorNode.elements {
                let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = usedAngle || elementUsedAngle
                elements.append(evaluatedElement)
            }
            let (values, commonDimension) = try extractValuesAndDimension(from: elements)
            return (.vector(Vector(values: values, dimensions: commonDimension)), usedAngle)

        case let matrixNode as MatrixNode:
            var allElements: [MathValue] = []
            for row in matrixNode.rows {
                for elementNode in row {
                    let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                    usedAngle = usedAngle || elementUsedAngle
                    allElements.append(evaluatedElement)
                }
            }
            let (values, commonDimension) = try extractValuesAndDimension(from: allElements)
            let rows = matrixNode.rows.count
            let columns = matrixNode.rows.first?.count ?? 0
            return (.matrix(Matrix(values: values, rows: rows, columns: columns, dimensions: commonDimension)), usedAngle)
            
        case let cVectorNode as ComplexVectorNode:
            var elements: [MathValue] = []
            for elementNode in cVectorNode.elements {
                let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = usedAngle || elementUsedAngle
                elements.append(evaluatedElement)
            }
            let (complexValues, commonDimension) = try extractComplexValuesAndDimension(from: elements)
            return (.complexVector(ComplexVector(values: complexValues, dimensions: commonDimension)), usedAngle)

        case let cMatrixNode as ComplexMatrixNode:
            var allElements: [MathValue] = []
            for row in cMatrixNode.rows {
                for elementNode in row {
                    let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                    usedAngle = usedAngle || elementUsedAngle
                    allElements.append(evaluatedElement)
                }
            }
            let (complexValues, commonDimension) = try extractComplexValuesAndDimension(from: allElements)
            let rows = cMatrixNode.rows.count
            let columns = cMatrixNode.rows.first?.count ?? 0
            return (.complexMatrix(ComplexMatrix(values: complexValues, rows: rows, columns: columns, dimensions: commonDimension)), usedAngle)

        case let unaryNode as UnaryOpNode:
            let (childValue, childUsedAngle) = try _evaluateSingle(node: unaryNode.child, variables: &variables, functions: &functions, angleMode: angleMode)
            let result = try evaluateUnaryOperation(op: unaryNode.op, value: childValue)
            return (result, childUsedAngle)
            
        case let postfixNode as PostfixOpNode:
             let (childValue, childUsedAngle) = try _evaluateSingle(node: postfixNode.child, variables: &variables, functions: &functions, angleMode: angleMode)
             let result = try evaluateUnaryOperation(op: postfixNode.op, value: childValue)
             return (result, childUsedAngle)

        case let binaryNode as BinaryOpNode:
            if binaryNode.op.rawValue == "∠" {
                let (rValue, rUsedAngle) = try _evaluateSingle(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
                let (thetaValue, thetaUsedAngle) = try _evaluateSingle(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = rUsedAngle || thetaUsedAngle
                guard case .dimensionless(let r) = rValue, case .dimensionless(let theta) = thetaValue else { throw MathError.typeMismatch(expected: "Dimensionless ∠ Dimensionless", found: "\(rValue.typeName) ∠ \(thetaValue.typeName)") }
                let thetaRad = angleMode == .degrees ? theta * .pi / 180.0 : theta
                return (.complex(Complex(real: r * cos(thetaRad), imaginary: r * sin(thetaRad))), true)
            }
            
            let (leftValue, leftUsedAngle) = try _evaluateSingle(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
            
            if let indexedOpNode = binaryNode.right as? IndexedOperationNode {
                return try evaluateIndexedAssignment(op: binaryNode.op, target: leftValue, indexedOp: indexedOpNode, variables: &variables, functions: &functions, angleMode: angleMode)
            }

            let (rightValue, rightUsedAngle) = try _evaluateSingle(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
            let result = try evaluateBinaryOperation(op: binaryNode.op, left: leftValue, right: rightValue)
            return (result, leftUsedAngle || rightUsedAngle)

        case let derivativeNode as DerivativeNode:
            let (bodyNode, varName): (ExpressionNode, String)
            let pointNode = derivativeNode.point

            if let variableNode = derivativeNode.variable {
                bodyNode = derivativeNode.body
                varName = variableNode.name
            } else {
                let funcName: String
                if let funcNameNode = derivativeNode.body as? ConstantNode { funcName = funcNameNode.name }
                else if let funcCallNode = derivativeNode.body as? FunctionCallNode { funcName = funcCallNode.name }
                else { throw MathError.incorrectArgumentCount(function: "derivative", expected: "3 arguments (expression, variable, point) for this type of expression", found: 2) }
                
                guard let userFunction = functions[funcName] else { throw MathError.unknownFunction(name: funcName) }
                guard userFunction.parameterNames.count == 1 else { throw MathError.unsupportedOperation(op: "derivative", typeA: "function with \(userFunction.parameterNames.count) variables in 2-argument form", typeB: nil) }
                bodyNode = userFunction.body
                varName = userFunction.parameterNames[0]
            }

            let (pointValue, pointUsedAngle) = try _evaluateSingle(node: pointNode, variables: &variables, functions: &functions, angleMode: angleMode)
            let (orderValue, _) = try _evaluateSingle(node: derivativeNode.order, variables: &variables, functions: &functions, angleMode: angleMode)
            
            // --- FIX: Replaced ambiguous asUnitValue() with a switch statement ---
            let pointUnitValue: UnitValue
            switch pointValue {
            case .dimensionless(let d): pointUnitValue = .dimensionless(d)
            case .unitValue(let u): pointUnitValue = u
            default: throw MathError.typeMismatch(expected: "A scalar value for the derivative point", found: pointValue.typeName)
            }

            guard case .dimensionless(let orderScalar) = orderValue, orderScalar >= 1, orderScalar.truncatingRemainder(dividingBy: 1) == 0 else { throw MathError.typeMismatch(expected: "Positive integer for derivative order", found: orderValue.typeName) }
            let order = Int(orderScalar)

            var tempVarsForDryRun = variables
            tempVarsForDryRun[varName] = .unitValue(pointUnitValue)
            let (_, bodyUsedAngle) = try _evaluateSingle(node: bodyNode, variables: &tempVarsForDryRun, functions: &functions, angleMode: angleMode)
            
            let result = try calculateNthDerivative(bodyNode: bodyNode, varName: varName, at: pointUnitValue, order: order, variables: &variables, functions: &functions, angleMode: angleMode)
            return (.unitValue(result), pointUsedAngle || bodyUsedAngle)

        case let integralNode as IntegralNode:
            let (lowerValue, lowerUsedAngle) = try _evaluateSingle(node: integralNode.lowerBound, variables: &variables, functions: &functions, angleMode: angleMode)
            let (upperValue, upperUsedAngle) = try _evaluateSingle(node: integralNode.upperBound, variables: &variables, functions: &functions, angleMode: angleMode)

            // --- FIX: Replaced ambiguous asUnitValue() with switch statements ---
            let a: UnitValue, b: UnitValue
            switch lowerValue {
            case .dimensionless(let d): a = .dimensionless(d)
            case .unitValue(let u): a = u
            default: throw MathError.typeMismatch(expected: "Scalar values for integral bounds", found: lowerValue.typeName)
            }
            switch upperValue {
            case .dimensionless(let d): b = .dimensionless(d)
            case .unitValue(let u): b = u
            default: throw MathError.typeMismatch(expected: "Scalar values for integral bounds", found: upperValue.typeName)
            }
            
            guard a.dimensions == b.dimensions else {
                throw MathError.dimensionMismatch(reason: "Integral bounds must have the same units")
            }

            var bodyUsedAngle = false
            let f: (UnitValue) throws -> UnitValue = { x_unit in
                let (value, f_usedAngle) = try self.evaluateWithTempVar(
                    node: integralNode.body,
                    varName: integralNode.variable.name,
                    varValue: .unitValue(x_unit),
                    variables: &variables,
                    functions: &functions,
                    angleMode: angleMode
                )
                bodyUsedAngle = bodyUsedAngle || f_usedAngle
                
                // --- FIX: Replaced ambiguous asUnitValue() with a switch statement ---
                let resultUnit: UnitValue
                switch value {
                case .dimensionless(let d): resultUnit = .dimensionless(d)
                case .unitValue(let u): resultUnit = u
                default: throw MathError.typeMismatch(expected: "A value with units from integral body", found: value.typeName)
                }
                return resultUnit
            }
                
            let tolerance = 1e-7
            let result = try adaptiveSimpson(f: f, a: a, b: b, tolerance: tolerance)
                    
            return (.unitValue(result), lowerUsedAngle || upperUsedAngle || bodyUsedAngle)

        case let primeNode as PrimeDerivativeNode:
            guard let userFunction = functions[primeNode.functionName] else {
                throw MathError.unknownFunction(name: primeNode.functionName)
            }
            guard userFunction.parameterNames.count == 1 else {
                throw MathError.incorrectArgumentCount(function: "\(primeNode.functionName)'", expected: "1", found: userFunction.parameterNames.count)
            }
            let varName = userFunction.parameterNames[0]

            let (pointValue, pointUsedAngle) = try _evaluateSingle(node: primeNode.argument, variables: &variables, functions: &functions, angleMode: angleMode)
            
            // --- FIX: Replaced ambiguous asUnitValue() with a switch statement ---
            let pointUnitValue: UnitValue
            switch pointValue {
            case .dimensionless(let d): pointUnitValue = .dimensionless(d)
            case .unitValue(let u): pointUnitValue = u
            default: throw MathError.typeMismatch(expected: "A scalar value for the derivative point", found: pointValue.typeName)
            }

            var tempVars = variables
            tempVars[varName] = .unitValue(pointUnitValue)
            let (_, bodyUsedAngle) = try _evaluateSingle(node: userFunction.body, variables: &tempVars, functions: &functions, angleMode: angleMode)
            
            let h_unit = UnitValue(value: h, dimensions: pointUnitValue.dimensions)

            let valPlus_Math = try evaluateWithTempVar(node: userFunction.body, varName: varName, varValue: .unitValue(try pointUnitValue + h_unit), variables: &variables, functions: &functions, angleMode: angleMode).result
            let valMinus_Math = try evaluateWithTempVar(node: userFunction.body, varName: varName, varValue: .unitValue(try pointUnitValue - h_unit), variables: &variables, functions: &functions, angleMode: angleMode).result
            
            guard let valPlus = valPlus_Math.asUnitValue(), let valMinus = valMinus_Math.asUnitValue() else {
                throw MathError.typeMismatch(expected: "A value with units for derivative calculation", found: "\(valPlus_Math.typeName) or \(valMinus_Math.typeName)")
            }

            let numerator = try valPlus - valMinus
            let denominator = UnitValue(value: 2 * h, dimensions: pointUnitValue.dimensions)
            let derivative = try numerator / denominator
            
            return (.unitValue(derivative), pointUsedAngle || bodyUsedAngle)
            
        case let autoplotNode as AutoplotNode:
            return try (evaluateAutoplot(autoplotNode, variables: &variables, functions: &functions), false)
            
        case let plotNode as PlotNode:
            return try (evaluatePlot(plotNode, variables: &variables, functions: &functions), false)

        case let scatterNode as ScatterplotNode:
            return try (evaluateScatterplot(scatterNode, variables: &variables, functions: &functions), false)

        case let solveNode as SolveNode:
            return try evaluateSolve(solveNode, variables: &variables, functions: &functions, angleMode: angleMode)
            
        case let odeNode as ODENode:
            return try (evaluateODESolve(odeNode, variables: &variables, functions: &functions, angleMode: angleMode), false)

        case is ImportCSVNode:
            return (.triggerCSVImport, false)

        default:
            throw MathError.invalidNode
        }
    }
    
    // --- REWRITTEN: Function to handle all matrix/vector indexing cases ---
    private func evaluateIndexAccess(target: MathValue, argNodes: [ExpressionNode], variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (result: MathValue, usedAngle: Bool) {

        // Helper to evaluate a single index component (e.g., '3', 'end', '1:5', 'v>5')
        func evaluateIndexArgument(node: ExpressionNode, maxDimension: Int) throws -> [Int] {
            
            // Inner helper to resolve a single integer value which could be a number or 'end'
            func resolveIndexValue(node: ExpressionNode) throws -> Int {
                if let constNode = node as? ConstantNode, constNode.name == "end" {
                    return maxDimension
                }
                let (value, _) = try _evaluateSingle(node: node, variables: &variables, functions: &functions, angleMode: angleMode)
                let scalar = try value.asScalar()
                guard scalar.truncatingRemainder(dividingBy: 1) == 0 else {
                    throw MathError.typeMismatch(expected: "Integer for index", found: "Non-integer value")
                }
                return Int(scalar)
            }

            // Case 1: Range operator 'start:end'
            if let binaryNode = node as? BinaryOpNode, binaryNode.op.rawValue == ":" {
                let startIdx = try resolveIndexValue(node: binaryNode.left)
                let endIdx = try resolveIndexValue(node: binaryNode.right)
                
                guard startIdx <= endIdx else { return [] } // Empty range is valid
                return Array(startIdx...endIdx)
            }
            
            // Case 2: Standalone ':' for full dimension, or a single number/end
            if let constNode = node as? ConstantNode {
                switch constNode.name {
                case "end":
                    return [maxDimension]
                case ":":
                    return Array(1...maxDimension)
                default:
                    // It's a variable name, which could be part of a logical expression. Fall through.
                    break
                }
            }
            
            // Case 3: A single number node, not captured by logical indexing
            if node is NumberNode {
                 let index = try resolveIndexValue(node: node)
                 return [index]
            }
            
            // Case 4: Logical Indexing (e.g., v(v>5)). This is the fallback.
            let (logicalValue, _) = try _evaluateSingle(node: node, variables: &variables, functions: &functions, angleMode: angleMode)
            
            // --- NEW: Handle both vector and matrix logical indices ---
            let logicalValues: [Double]
            let logicalCount: Int
            
            switch logicalValue {
            case .vector(let v):
                logicalValues = v.values
                logicalCount = v.dimension
            case .matrix(let m):
                logicalValues = m.values
                logicalCount = m.values.count
            default:
                throw MathError.typeMismatch(expected: "Logical vector or matrix (e.g., v > 5) for indexing", found: logicalValue.typeName)
            }

            guard logicalCount == maxDimension else {
                throw MathError.dimensionMismatch(reason: "Logical index must have same number of elements as the target (\(logicalCount) vs \(maxDimension)).")
            }
            
            var indices: [Int] = []
            for (i, value) in logicalValues.enumerated() {
                if value != 0 {
                    indices.append(i + 1) // Convert from 0-based to 1-based index
                }
            }
            return indices
        }
        
        // Main logic for evaluateIndexAccess
        switch target {
        case .vector(let v):
            guard argNodes.count == 1 else { throw MathError.incorrectArgumentCount(function: "Vector indexing", expected: "1", found: argNodes.count) }
            let indices = try evaluateIndexArgument(node: argNodes[0], maxDimension: v.dimension)
            return (try v.slice(indices: indices), false)
            
        case .matrix(let m):
            if argNodes.count == 1 {
                // Handle linear/logical indexing for matrices, e.g., m(m>5) or m(3)
                let indices = try evaluateIndexArgument(node: argNodes[0], maxDimension: m.values.count)
                
                var newValues: [Double] = []
                for index in indices {
                    // Using 1-based indexing for user input
                    guard index >= 1 && index <= m.values.count else {
                        throw MathError.dimensionMismatch(reason: "Index \(index) is out of bounds for matrix with \(m.values.count) elements.")
                    }
                    newValues.append(m.values[index - 1])
                }

                // A single element is returned as a scalar
                if newValues.count == 1 {
                    return (.unitValue(UnitValue(value: newValues[0], dimensions: m.dimensions)), false)
                }
                
                // Multiple elements are returned as a column vector (Nx1 matrix)
                return (.matrix(Matrix(values: newValues, rows: newValues.count, columns: 1, dimensions: m.dimensions)), false)

            } else if argNodes.count == 2 {
                // Keep existing logic for m(row, col) indexing
                let rowIndices = try evaluateIndexArgument(node: argNodes[0], maxDimension: m.rows)
                let colIndices = try evaluateIndexArgument(node: argNodes[1], maxDimension: m.columns)
                return (try m.slice(rowIndices: rowIndices, colIndices: colIndices), false)
            } else {
                // Throw error for incorrect number of arguments
                throw MathError.incorrectArgumentCount(function: "Matrix indexing", expected: "1 or 2", found: argNodes.count)
            }

        case .complexVector(let cv):
            guard argNodes.count == 1 else { throw MathError.incorrectArgumentCount(function: "Complex vector indexing", expected: "1", found: argNodes.count) }
            let indices = try evaluateIndexArgument(node: argNodes[0], maxDimension: cv.dimension)
            return (try cv.slice(indices: indices), false)
            
        case .complexMatrix(let cm):
             if argNodes.count == 1 {
                let indices = try evaluateIndexArgument(node: argNodes[0], maxDimension: cm.values.count)
                var newValues: [Complex] = []
                for index in indices {
                    guard index >= 1 && index <= cm.values.count else {
                        throw MathError.dimensionMismatch(reason: "Index \(index) is out of bounds for complex matrix with \(cm.values.count) elements.")
                    }
                    newValues.append(cm.values[index - 1])
                }
                if newValues.count == 1 {
                     return (.complex(newValues[0]), false) // Assuming dimensionless for now
                }
                return (.complexMatrix(ComplexMatrix(values: newValues, rows: newValues.count, columns: 1, dimensions: cm.dimensions)), false)
             } else if argNodes.count == 2 {
                let rowIndices = try evaluateIndexArgument(node: argNodes[0], maxDimension: cm.rows)
                let colIndices = try evaluateIndexArgument(node: argNodes[1], maxDimension: cm.columns)
                return (try cm.slice(rowIndices: rowIndices, colIndices: colIndices), false)
             } else {
                throw MathError.incorrectArgumentCount(function: "Complex matrix indexing", expected: "1 or 2", found: argNodes.count)
             }

        default:
            // This case should not be hit due to the check in evaluateFunctionCall
            throw MathError.typeMismatch(expected: "Matrix or Vector", found: target.typeName)
        }
    }
}

// --- FIX: Helper function to build a unit-aware Vector/Matrix ---
/// Extracts numeric values and a common unit dimension from a list of MathValues.
/// This version allows dimensionless values (especially zero) to conform to the vector's unit type.
private func extractValuesAndDimension(from elements: [MathValue]) throws -> (values: [Double], dimensions: UnitDimension) {
    guard !elements.isEmpty else {
        return ([], [:])
    }
    
    var commonDimension: UnitDimension? = nil
    // First pass: find a non-dimensionless unit to establish the vector's unit type.
    for element in elements {
        if case .unitValue(let u) = element, !u.dimensions.isEmpty {
            commonDimension = u.dimensions
            break
        }
    }
    // If no element with units was found, the vector is dimensionless.
    let finalDimension = commonDimension ?? [:]
    
    var values: [Double] = []
    for element in elements {
        switch element {
        case .dimensionless(let d):
            values.append(d)
        case .unitValue(let u):
            // An element is compatible if its dimension matches the vector's,
            // or if the element is dimensionless (it can adopt the vector's unit).
            if u.dimensions == finalDimension {
                values.append(u.value)
            } else if u.dimensions.isEmpty {
                 values.append(u.value)
            } else if finalDimension.isEmpty {
                // This occurs if the first element had units, but a later one is dimensionless
                throw MathError.dimensionMismatch(reason: "All elements in a vector or matrix must have the same units")
            } else {
                 throw MathError.dimensionMismatch(reason: "All elements in a vector or matrix must have the same units")
            }
        default:
            throw MathError.typeMismatch(expected: "Numeric value (with or without units)", found: element.typeName)
        }
    }
    
    return (values, finalDimension)
}

// --- FIX: Helper function to build a unit-aware ComplexVector/ComplexMatrix ---
/// Extracts complex values and a common unit dimension, allowing dimensionless values to conform.
private func extractComplexValuesAndDimension(from elements: [MathValue]) throws -> (values: [Complex], dimensions: UnitDimension) {
    guard !elements.isEmpty else {
        return ([], [:])
    }
    
    var commonDimension: UnitDimension? = nil
    // First pass to find a non-dimensionless unit.
    for element in elements {
        if case .unitValue(let u) = element, !u.dimensions.isEmpty {
            commonDimension = u.dimensions
            break
        }
    }
    let finalDimension = commonDimension ?? [:]
    
    var values: [Complex] = []
    for element in elements {
        let currentDimension: UnitDimension
        let currentValue: Complex
        
        switch element {
        case .dimensionless(let d):
            currentValue = Complex(real: d, imaginary: 0)
            currentDimension = [:]
        case .unitValue(let u):
            currentValue = Complex(real: u.value, imaginary: 0)
            currentDimension = u.dimensions
        case .complex(let c):
            currentValue = c
            currentDimension = [:] // Complex numbers are inherently dimensionless in this system
        default:
            throw MathError.typeMismatch(expected: "Numeric or Complex value", found: element.typeName)
        }
        
        if currentDimension == finalDimension || currentDimension.isEmpty {
            values.append(currentValue)
        } else if finalDimension.isEmpty {
            throw MathError.dimensionMismatch(reason: "All elements in a complex vector or matrix must have the same units")
        } else {
            throw MathError.dimensionMismatch(reason: "All elements in a complex vector or matrix must have the same units")
        }
    }
    
    return (values, finalDimension)
}

