import Foundation

enum MathError: Error, CustomStringConvertible {
    case divisionByZero
    case unknownOperator(op: String)
    case unknownConstant(name: String)
    case unknownFunction(name: String)
    case invalidNode
    case typeMismatch(expected: String, found: String)
    case unsupportedOperation(op: String, typeA: String, typeB: String?)
    case dimensionMismatch(reason: String)
    case incorrectArgumentCount(function: String, expected: String, found: Int)
    case requiresAtLeastOneArgument(function: String)
    case plotError(reason: String)

    var description: String {
        switch self {
        case .divisionByZero: return "Error: Division by zero."
        case .unknownOperator(let op): return "Error: Unknown operator '\(op)'."
        case .unknownConstant(let name): return "Error: Unknown variable or constant '\(name)'."
        case .unknownFunction(let name): return "Error: Unknown function '\(name)'."
        case .invalidNode: return "Error: The expression tree contains an invalid node."
        case .typeMismatch(let expected, let found): return "Error: Type mismatch. Expected \(expected), but found \(found)."
        case .unsupportedOperation(let op, let typeA, let typeB):
            if let typeB = typeB {
                if typeA == "Tuple" && typeB == "Tuple" {
                    return "Error: Operations between two multi-valued results are not supported."
                }
                return "Error: Operator '\(op)' is not supported between \(typeA) and \(typeB)."
            }
            if typeA == "hyp < side" { return "Error: Hypotenuse must be greater than or equal to the side." }
            if typeA == "Singular Matrix" { return "Error: Matrix is singular and cannot be inverted."}
            return "Error: Operator '\(op)' is not supported for \(typeA)."
        case .dimensionMismatch(let reason): return "Error: Dimension mismatch. \(reason)."
        case .incorrectArgumentCount(let function, let expected, let found): return "Error: Function '\(function)' expects \(expected) argument(s), but received \(found)."
        case .requiresAtLeastOneArgument(let function): return "Error: Function '\(function)' requires at least one argument."
        case .plotError(let reason): return "Plot Error: \(reason)."
        }
    }
}

/// The core evaluation engine. This struct contains the main recursive evaluation loop (`_evaluateSingle`)
/// that traverses the abstract syntax tree (AST) generated by the Parser.
struct Evaluator {

    let h = 1e-5 // A small step size for numerical differentiation

    /// A helper function to evaluate an expression with a temporary variable, used for calculus operations.
    func evaluateWithTempVar(node: ExpressionNode, varName: String, varValue: Double, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> MathValue {
        var tempVars = variables
        tempVars[varName] = .scalar(varValue)
        let (result, _) = try _evaluateSingle(node: node, variables: &tempVars, functions: &functions, angleMode: angleMode)
        return result
    }
    
    /// The main entry point for evaluating an expression node. It handles expanding multi-value results (from `±`).
    func evaluate(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (result: MathValue, usedAngle: Bool) {
        let (results, usedAngle) = try evaluateAndExpand(node: node, variables: &variables, functions: &functions, angleMode: angleMode)
        if results.count == 1 {
            return (results[0], usedAngle)
        } else {
            return (.tuple(results), usedAngle)
        }
    }
    
    /// Recursively evaluates an expression, handling the `±` operator by creating multiple evaluation paths.
    private func evaluateAndExpand(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (results: [MathValue], usedAngle: Bool) {
        if let binaryNode = node as? BinaryOpNode, binaryNode.op.rawValue == "±" {
            let (leftResults, leftUsedAngle) = try evaluateAndExpand(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
            let (rightResults, rightUsedAngle) = try evaluateAndExpand(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
            
            var combinedResults: [MathValue] = []
            for l in leftResults {
                for r in rightResults {
                    combinedResults.append(try evaluateBinaryOperation(op: Token(type: .op("+"), rawValue: "+"), left: l, right: r))
                    combinedResults.append(try evaluateBinaryOperation(op: Token(type: .op("-"), rawValue: "-"), left: l, right: r))
                }
            }
            return (combinedResults, leftUsedAngle || rightUsedAngle)
        }
        
        let (result, nodeUsedAngle) = try _evaluateSingle(node: node, variables: &variables, functions: &functions, angleMode: angleMode)
        return ([result], nodeUsedAngle)
    }

    /// The core recursive function that evaluates a single node of the expression tree.
    func _evaluateSingle(node: ExpressionNode, variables: inout [String: MathValue], functions: inout [String: FunctionDefinitionNode], angleMode: AngleMode) throws -> (result: MathValue, usedAngle: Bool) {
        var usedAngle = false
        
        switch node {
        case let numberNode as NumberNode:
            return (.scalar(numberNode.value), usedAngle)
        
        case let stringNode as StringNode: // NEW: Handle StringNode
            return (.constant(stringNode.value), false)
            
        case let constantNode as ConstantNode:
            if constantNode.name == "i" { return (.complex(Complex.i), usedAngle) }
            if let value = variables[constantNode.name] { return (value, usedAngle) }
            else if let value = Evaluator.siPrefixes[constantNode.name] { return (.scalar(value), usedAngle) }
            else if let value = Evaluator.constants[constantNode.name] { return (.scalar(value), usedAngle) }
            else { throw MathError.unknownConstant(name: constantNode.name) }
            
        case let assignmentNode as AssignmentNode:
            let (value, valueUsedAngle) = try evaluate(node: assignmentNode.expression, variables: &variables, functions: &functions, angleMode: angleMode)
            variables[assignmentNode.name] = value
            return (value, valueUsedAngle)

        case let funcDefNode as FunctionDefinitionNode:
            functions[funcDefNode.name] = funcDefNode
            return (.functionDefinition(funcDefNode.name), usedAngle)
            
        case let functionNode as FunctionCallNode:
            return try evaluateFunctionCall(functionNode, variables: &variables, functions: &functions, angleMode: angleMode)
            
        case let vectorNode as VectorNode:
            var elements: [Double] = []
            for elementNode in vectorNode.elements {
                let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = usedAngle || elementUsedAngle
                guard case .scalar(let scalarElement) = evaluatedElement else { throw MathError.typeMismatch(expected: "Scalar", found: "Non-scalar in vector definition") }
                elements.append(scalarElement)
            }
            return (.vector(Vector(values: elements)), usedAngle)
            
        case let matrixNode as MatrixNode:
            var values: [Double] = []
            let rows = matrixNode.rows.count; let columns = matrixNode.rows.first?.count ?? 0
            for row in matrixNode.rows {
                for elementNode in row {
                    let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                    usedAngle = usedAngle || elementUsedAngle
                    guard case .scalar(let scalarElement) = evaluatedElement else { throw MathError.typeMismatch(expected: "Scalar", found: "Non-scalar in matrix definition") }
                    values.append(scalarElement)
                }
            }
            return (.matrix(Matrix(values: values, rows: rows, columns: columns)), usedAngle)

        case let cVectorNode as ComplexVectorNode:
            var elements: [Complex] = []
            for elementNode in cVectorNode.elements {
                let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = usedAngle || elementUsedAngle
                switch evaluatedElement {
                case .complex(let c): elements.append(c)
                case .scalar(let s): elements.append(Complex(real: s, imaginary: 0))
                default: throw MathError.typeMismatch(expected: "Complex or Scalar", found: evaluatedElement.typeName)
                }
            }
            return (.complexVector(ComplexVector(values: elements)), usedAngle)

        case let cMatrixNode as ComplexMatrixNode:
            var values: [Complex] = []; let rows = cMatrixNode.rows.count; let columns = cMatrixNode.rows.first?.count ?? 0
            for row in cMatrixNode.rows {
                for elementNode in row {
                    let (evaluatedElement, elementUsedAngle) = try _evaluateSingle(node: elementNode, variables: &variables, functions: &functions, angleMode: angleMode)
                    usedAngle = usedAngle || elementUsedAngle
                    switch evaluatedElement {
                    case .complex(let c): values.append(c)
                    case .scalar(let s): values.append(Complex(real: s, imaginary: 0))
                    default: throw MathError.typeMismatch(expected: "Complex or Scalar", found: evaluatedElement.typeName)
                    }
                }
            }
            return (.complexMatrix(ComplexMatrix(values: values, rows: rows, columns: columns)), usedAngle)

        case let unaryNode as UnaryOpNode:
            let (childValue, childUsedAngle) = try _evaluateSingle(node: unaryNode.child, variables: &variables, functions: &functions, angleMode: angleMode)
            let result = try evaluateUnaryOperation(op: unaryNode.op, value: childValue)
            return (result, childUsedAngle)
            
        case let postfixNode as PostfixOpNode:
             let (childValue, childUsedAngle) = try _evaluateSingle(node: postfixNode.child, variables: &variables, functions: &functions, angleMode: angleMode)
             let result = try evaluateUnaryOperation(op: postfixNode.op, value: childValue)
             return (result, childUsedAngle)

        case let binaryNode as BinaryOpNode:
            if binaryNode.op.rawValue == "∠" {
                let (rValue, rUsedAngle) = try _evaluateSingle(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
                let (thetaValue, thetaUsedAngle) = try _evaluateSingle(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
                usedAngle = rUsedAngle || thetaUsedAngle
                guard case .scalar(let r) = rValue, case .scalar(let theta) = thetaValue else { throw MathError.typeMismatch(expected: "Scalar ∠ Scalar", found: "\(rValue.typeName) ∠ \(thetaValue.typeName)") }
                let thetaRad = angleMode == .degrees ? theta * .pi / 180.0 : theta
                return (.complex(Complex(real: r * cos(thetaRad), imaginary: r * sin(thetaRad))), true)
            }
            
            let (leftValue, leftUsedAngle) = try _evaluateSingle(node: binaryNode.left, variables: &variables, functions: &functions, angleMode: angleMode)
            
            if let indexedOpNode = binaryNode.right as? IndexedOperationNode {
                return try evaluateIndexedAssignment(op: binaryNode.op, target: leftValue, indexedOp: indexedOpNode, variables: &variables, functions: &functions, angleMode: angleMode)
            }

            let (rightValue, rightUsedAngle) = try _evaluateSingle(node: binaryNode.right, variables: &variables, functions: &functions, angleMode: angleMode)
            let result = try evaluateBinaryOperation(op: binaryNode.op, left: leftValue, right: rightValue)
            return (result, leftUsedAngle || rightUsedAngle)

        case let derivativeNode as DerivativeNode:
            let (bodyNode, varName): (ExpressionNode, String)
            let pointNode = derivativeNode.point

            if let variableNode = derivativeNode.variable {
                bodyNode = derivativeNode.body
                varName = variableNode.name
            } else {
                let funcName: String
                if let funcNameNode = derivativeNode.body as? ConstantNode {
                    funcName = funcNameNode.name
                } else if let funcCallNode = derivativeNode.body as? FunctionCallNode {
                    funcName = funcCallNode.name
                } else {
                    throw MathError.incorrectArgumentCount(function: "derivative", expected: "3 arguments (expression, variable, point) for this type of expression", found: 2)
                }
                
                guard let userFunction = functions[funcName] else { throw MathError.unknownFunction(name: funcName) }
                guard userFunction.parameterNames.count == 1 else { throw MathError.unsupportedOperation(op: "derivative", typeA: "function with \(userFunction.parameterNames.count) variables in 2-argument form", typeB: nil) }
                bodyNode = userFunction.body
                varName = userFunction.parameterNames[0]
            }

            let (pointValue, pointUsedAngle) = try _evaluateSingle(node: pointNode, variables: &variables, functions: &functions, angleMode: angleMode)
            let (orderValue, _) = try _evaluateSingle(node: derivativeNode.order, variables: &variables, functions: &functions, angleMode: angleMode)

            guard case .scalar(let point) = pointValue else { throw MathError.typeMismatch(expected: "Scalar for differentiation point", found: pointValue.typeName) }
            guard case .scalar(let orderScalar) = orderValue, orderScalar >= 1, orderScalar.truncatingRemainder(dividingBy: 1) == 0 else { throw MathError.typeMismatch(expected: "Positive integer for derivative order", found: orderValue.typeName) }
            let order = Int(orderScalar)

            var tempVarsForDryRun = variables
            tempVarsForDryRun[varName] = .scalar(0)
            let bodyUsedAngle = (try? _evaluateSingle(node: bodyNode, variables: &tempVarsForDryRun, functions: &functions, angleMode: angleMode))?.usedAngle ?? false
            
            let result = try calculateNthDerivative(bodyNode: bodyNode, varName: varName, at: point, order: order, variables: &variables, functions: &functions, angleMode: angleMode)
            return (.scalar(result), pointUsedAngle || bodyUsedAngle)

        case let integralNode as IntegralNode:
            let (lowerValue, lowerUsedAngle) = try _evaluateSingle(node: integralNode.lowerBound, variables: &variables, functions: &functions, angleMode: angleMode)
            let (upperValue, upperUsedAngle) = try _evaluateSingle(node: integralNode.upperBound, variables: &variables, functions: &functions, angleMode: angleMode)

            guard case .scalar(let a) = lowerValue, case .scalar(let b) = upperValue else {
                throw MathError.typeMismatch(expected: "Scalar for integration bounds", found: "Non-scalar")
            }

            var tempVarsForDryRun = variables
            tempVarsForDryRun[integralNode.variable.name] = .scalar(0)
            let bodyUsedAngle = (try? _evaluateSingle(node: integralNode.body, variables: &tempVarsForDryRun, functions: &functions, angleMode: angleMode))?.usedAngle ?? false

            let f: (Double) throws -> Double = { x in
                var localVars = variables
                var localFuncs = functions
                let value = try self.evaluateWithTempVar(
                    node: integralNode.body,
                    varName: integralNode.variable.name,
                    varValue: x,
                    variables: &localVars,
                    functions: &localFuncs,
                    angleMode: angleMode
                )
                guard case .scalar(let scalarValue) = value else {
                    throw MathError.typeMismatch(expected: "Scalar expression for integration", found: value.typeName)
                }
                return scalarValue
            }
                
            let tolerance = 1e-7
            let result = try adaptiveSimpson(f: f, a: a, b: b, tolerance: tolerance)
                    
            return (.scalar(result), lowerUsedAngle || upperUsedAngle || bodyUsedAngle)

        case let primeNode as PrimeDerivativeNode:
            guard let userFunction = functions[primeNode.functionName] else {
                throw MathError.unknownFunction(name: primeNode.functionName)
            }
            guard userFunction.parameterNames.count == 1 else {
                throw MathError.incorrectArgumentCount(function: "\(primeNode.functionName)'", expected: "1", found: userFunction.parameterNames.count)
            }
            let varName = userFunction.parameterNames[0]

            let (pointValue, pointUsedAngle) = try _evaluateSingle(node: primeNode.argument, variables: &variables, functions: &functions, angleMode: angleMode)
            guard case .scalar(let point) = pointValue else {
                throw MathError.typeMismatch(expected: "Scalar for differentiation point", found: pointValue.typeName)
            }

            var tempVars = variables
            tempVars[varName] = .scalar(point)
            let bodyUsedAngle = (try? _evaluateSingle(node: userFunction.body, variables: &tempVars, functions: &functions, angleMode: angleMode))?.usedAngle ?? false

            let valPlus = try evaluateWithTempVar(node: userFunction.body, varName: varName, varValue: point + h, variables: &variables, functions: &functions, angleMode: angleMode)
            let valMinus = try evaluateWithTempVar(node: userFunction.body, varName: varName, varValue: point - h, variables: &variables, functions: &functions, angleMode: angleMode)
            
            guard case .scalar(let scalarPlus) = valPlus, case .scalar(let scalarMinus) = valMinus else {
                throw MathError.typeMismatch(expected: "Scalar function for differentiation", found: "Non-scalar")
            }

            let derivative = (scalarPlus - scalarMinus) / (2 * h)
            return (.scalar(derivative), pointUsedAngle || bodyUsedAngle)
            
        case let autoplotNode as AutoplotNode:
            return try (evaluateAutoplot(autoplotNode, variables: &variables, functions: &functions), false)
            
        case let plotNode as PlotNode:
            return try (evaluatePlot(plotNode, variables: &variables, functions: &functions), false)

        case let scatterNode as ScatterplotNode:
            return try (evaluateScatterplot(scatterNode, variables: &variables, functions: &functions), false)

        case is ImportCSVNode:
            return (.triggerCSVImport, false)

        default:
            throw MathError.invalidNode
        }
    }
}
